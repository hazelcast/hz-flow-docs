= Querying with {short-product-name}
:description: Submitting queries to {short-product-name}'s API to discover data

import { Callout } from '@/components/docs/Callout';

{short-product-name} focuses on querying for data based on its meaning, rather than which system provides it. This allows services to
change, and data to move, without requiring consumers to update their queries.

////
TODO: replace diagram
![diagram](querying.png)
////

== Writing queries

Queries are written in https://docs.taxilang.org/language-reference/querying-with-taxiql/[TaxiQL], an open source
query language for data.+++<Callout>+++[TaxiQL](https://docs.taxilang.org/language-reference/querying-with-taxiql/) is a great query language. The Taxi documentation has details on the syntax, which we haven't duplicated here. Go check it out, then come back. We'll wait.+++</Callout>+++

TaxiQL is agnostic of where data comes from - it's left to {short-product-name} to discover data from the various sources that have been
connected.

Here are some sample queries:

[,taxi]
----
// Find all the movies
find { Movie[] }

// Find all the movies, enriching and projecting them to a different structure
find { Movie[] } as {
   title : MovieTitle
   director : DirectorName
   rating : RottenTomatoesScore
}[]
----

== Projections

Projections are a way of taking data from one place, then transforming and combining it with other data sources.

{short-product-name} uses the information present on the object being projected in order to call services and find other information.

For example:

[,taxi]
----
model Purchase {
   transactionId : TransactionId
   customerId : CustomerId
}

find { Purchases[] }
as {
  // Projections let you change field names, and reshape objects as required
  txn: TransactionId
  // Not present on the original Purchase object, so try to
  // find it using something we already know (in this case, the CustomerId)
  customerName: CustomerName
}
----

=== Data discovery rules

When projecting, {short-product-name} will use information present on the source object to discover data
on the target object.

Data can be fetched from a single operation that returns the value, or by invoking a chain
of operations to return the value.

==== Operations with @Id fields on return types

If the result of an operation is an object that exposes an `@Id` field, then only operations which accept that `@Id` field as
an input will be called.

For example:

[,taxi]
----
model Customer {
  @Id customerId : CustomerId
  name : CustomerName
}

service CustomerService {
   // Can be called when projecting, because
   // Person has an @Id of type PersonId
   findCustomer(CustomerId):Customer

   // Cannot be called when projecting, because
   // Person has an @Id, and it isn't PersonName
   findCustomerByName(CustomerName):Customer
}
----

==== Operations without @Id fields on return types

If the result of an operation is an object that _does not_ expose an `@Id` field, then it can be called with
any information available.

=== Filling in nulls

By default, if a service returns a null value, {short-product-name} will accept it 'as is'.

However, if a query annotates a field on a projection type with `@FirstNotEmpty`, {short-product-name} will
attempt to populate values by invoking operations to populate the missing values.

{short-product-name} will execute a search using the other values present on the entity being projected as potential
inputs to operations, and build a path to populate the missing values.

Operations are invoked following the standard <<data-discovery-rules,Data Discovery Rules>>.

== Understanding caching in {short-product-name}

By default, {short-product-name} does not maintain a long-lived cache between operations,
but you can link:/docs/describing-data-sources/caching[add one] by configuring an external cache, such as Redis or Hazelcast.

Without an external cache, {short-product-name} caches operation calls for the lifetime of a query. This prevents the same operation
being invoked repeatedly while projecting multiple rows in a result.

When caching, responses are cached for a given operation and set of inputs.  If an operation is invoked with
different parameters, the cache is not used.

Operations that return an array of results, and which return more than 10 values, will not have their responses cached.  (This is not
currently configurable, but reach out on Slack if you need to configure this).

== Recovering from failure

If an operation returns an error while {short-product-name} is attempting to execute a query, then it
is excluded from being invoked with the same parameters again.  This exclusion is
scoped to the query only, and expires at the end of the query.

After excluding the operation, {short-product-name} will attempt to find another path to return the
value being discovered.

== Expressions in queries

Taxi allows the definition of expressions on both https://docs.taxilang.org/language-reference/advanced-types/#expression-types[types] and https://docs.taxilang.org/language-reference/advanced-types/#expression-on-fields[fields], but doesn't
provide an evaluation engine - that's where {short-product-name} comes in.

Typically, expressions are used in a projection within a query.

You can also use them on a model to expose derived information when a model is parsed by {short-product-name} (e.g., when
returned from a service), but that's less common.  So, while this documentation focuses on query projections,
you can do everything here on a model too.

=== Writing an expression in a projection

Expressions can be defined in the fields of a projected result from a query:

[,taxi]
----
find { Flights[] }
as {
  flightNumber : FlightNumber
  totalSeatsAvailable : TotalSeats
  soldSeats : SoldSeats
  remainingSeats : Int = (this.totalSeatsAvailable - this.soldSeats)
}
----

Expressions can be defined in two ways: on a field, or on a type.

==== Expressions on a field

[,taxi]
----
// Expression types on a field:
find { Flights[] }
as {
  flightNumber : FlightNumber
  totalSeatsAvailable : TotalSeats
  soldSeats : SoldSeats
  // field expressions can be defined EITHER using field references...
  remainingSeats : Int = (this.totalSeatsAvailable - this.soldSeats)
  // ...or type references...
  remainingSeats : Int = (TotalSeats - SoldSeats)
}
----

==== Expressions on a type

To encapsulate common expressions, you can define a type with the expression:

[,taxi]
----
// Expression type:
type RemainingSeats = TotalSeats - SoldSeats

// Which is then used on a projection:
find { Flights[] }
as {
  flightNumber : FlightNumber
  totalSeatsAvailable : TotalSeats
  soldSeats : SoldSeats
  remainingSeats : RemainingSeats
}
----

Unlike field expressions, type expressions cannot use field names, and can only reference other types.

==== How {short-product-name} discovers values to evaluate expressions

When {short-product-name} is evaluating an expression, it first looks on the source object being projected
for the input values into the expression.

If any inputs are not available, then {short-product-name} will perform a search using the current data available on
the source object in an attempt to look up the value.

== Submitting queries

Generally, developers will use the UI to write and test their queries, then
integrate using {short-product-name}'s REST API.

=== REST API

Queries to {short-product-name} are submitted to the `/api/taxiql` endpoint:

----
curl 'http://localhost:9022/api/taxiql' \
  -H 'Content-Type: application/taxiql' \
  --data-raw 'find { Movie[] }'
----

==== A word about content type

Strictly speaking, the content type for TaxiQL queries is `application/taxiql`. However, the {short-product-name} server will accept
TaxiQL queries with any of the following content types headers:

* `Content-Type: application/json`
* `Content-Type: application/taxiql`
* `Content-Type: text/plain`

This is to allow broad compatability with clients.

=== Large queries with server-sent events

Running large queries can result in out-of-memory errors if {short-product-name} is holding the result set in memory.

To address this, {short-product-name} supports pushing results over server-sent events. To consume a query as a server-sent event, set
the `Accept` header to `text/event-stream`:

----
curl 'http://localhost:9022/api/taxiql' \
  -H 'Accept: text/event-stream' \
  -H 'Content-Type: application/taxiql' \
  --data-raw 'find { Movie[] }'
----

Results are pushed out from {short-product-name} as they are available.

=== Including type metadata in responses

{short-product-name} can include type metadata in the responses being sent back.

To enable this, append  `?resultMode=TYPED` to the API call:

----
curl 'http://localhost:9022/api/taxiql?resultMode=TYPED' \
  -H 'Accept: text/event-stream' \
  -H 'Content-Type: application/taxiql' \
  --data-raw 'find { Movie[] }'
----

== Defining output formats

By default, {short-product-name} serves results to queries as JSON.

This can be configured to customize the result format.

=== With Accept headers

The following Accept headers are supported:

|===
| Header | Result type

| `application/json`
| JSON

| `application/csv`
| CSV

| `text/event-stream
| JSON with server-sent events
|===

== Defining output formats with model formats

Fine-grained control is supported with custom model specs defined on model types.
At present, only limited support is provided, but we plan to provide additional formats
in a future release, along with the ability to register bespoke formats.

Formats are defined by adding an annotation to the model defined as the output type.

For example:

[,taxi]
----
import io.vyne.formats.Csv

@Csv(
   delimiter = "|",
   nullValue = "NULL"
)
model Person {
   firstName : String by column("firstName")
   lastName : String by column("lastName")
   age : Int by column("age")
}

// Query:
// Response type (Person) contains a CSV format defined,
// which will be considered when writing responses.
find { Customer[] }
as { Person[] }
----

=== CSV

The full definition of the CSV model format is as follows:

|===
| Parameter | Description | Required | Default Value

| delimiter
| Defines the delimiter to use between columns
| false
| ,

| firstRecordAsHeader
| Indicates if the first line should be treated as a header
| false
| true

| nullValue
| Defines a custom token to use in place of null
| false
| null

| containsTrailingDelimiters
| Indicates if the last delimiter is an empty column which should be ignored
| false
| false

| withQuote
| Defines a quote character used if content needs to be escaped
| false
| "
|===
